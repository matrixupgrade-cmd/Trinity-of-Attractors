import Mathlib.Data.Real.Basic
import Mathlib.Data.Matrix.Basic
import Mathlib.Algebra.BigOperators.Basic
import Mathlib.Tactic

open Matrix BigOperators Function

abbrev PhaseSpace := Fin 2 → ℝ

instance : NormedAddCommGroup PhaseSpace := Pi.normedAddCommGroup
instance : NormedSpace ℝ PhaseSpace := Pi.normedSpace

def normSq (x : PhaseSpace) : ℝ := x 0 ^ 2 + x 1 ^ 2
def distSq (x y : PhaseSpace) : ℝ := normSq (x - y)

structure DiscreteSystem where
  step : PhaseSpace → PhaseSpace

def iterate (sys : DiscreteSystem) : ℕ → PhaseSpace → PhaseSpace
  | 0,   x => x
  | n+1, x => iterate sys n (sys.step x)

def toy_step (a b : ℝ) (x : PhaseSpace) : PhaseSpace := fun i =>
  if i = 0
    then -x 0 - 5 * x 0 ^ 3 + a * (x 1 - x 0)
    else -x 1 - 5 * x 1 ^ 3 + b * (x 0 - x 1)

def toy_system (a b : ℝ) : DiscreteSystem := { step := toy_step a b }

def lyapunov_stable (sys : DiscreteSystem) (p : PhaseSpace) : Prop :=
  ∀ ε > 0, ∃ δ > 0, ∀ y, distSq y p < δ → ∀ t, distSq (iterate sys t y) p < ε

def NashEquilibrium (sys : DiscreteSystem) (p : PhaseSpace) : Prop :=
  sys.step p = p ∧ lyapunov_stable sys p

def Conflict (sys : DiscreteSystem) : Prop := ¬∃ p, NashEquilibrium sys p

def J (a b : ℝ) (x : PhaseSpace) : Matrix (Fin 2) (Fin 2) ℝ :=
  let p := x 0; let n := x 1
  !![ -1 - 15*p^2 - a , a
    ; b               , -1 - 15*n^2 - b ]

def a := 4
def b := 4

theorem origin_fixed : toy_step a b 0 = 0 := by
  ext i; fin_cases i <;> simp [toy_step, a, b] <;> ring

theorem J_at_origin : J a b 0 = !![ -5, 4 ; 4, -5 ] := by
  simp [J, a, b] <;> rfl

def v_exp : PhaseSpace := fun i => if i = 0 then 1 else -1

theorem expanding_eigenvalue_at_origin :
    (J a b 0).mulVec v_exp = (-9) • v_exp := by
  ext i; fin_cases i <;> simp [J_at_origin, v_exp, mulVec, dotProduct] <;> ring

theorem linear_map_powers_grow (t : ℕ) (ε : ℝ) :
    (J a b 0 ^ t).mulVec (ε • v_exp) = ε • ((-9) ^ t) • v_exp := by
  induction' t with t ih
  · simp [pow_zero, one_mulVec]
  · rw [pow_succ, mul_mulVec, ih]
    simp [expanding_eigenvalue_at_origin]

def L (u : PhaseSpace) : PhaseSpace := (J a b 0).mulVec u

def N (u : PhaseSpace) : PhaseSpace := toy_step a b u - L u

theorem toy_step_is_L_plus_N (u : PhaseSpace) : toy_step a b u = L u + N u := by
  rfl

theorem N_cubic_bound (ε : ℝ) (hε : 0 < ε) (u : PhaseSpace) (hu : ∀ i, |u i| ≤ ε) :
    normSq (N u) ≤ 80 * ε^3 * normSq u := by
  have : ∀ i, |N u i| ≤ 10 * ε^3 + 4 * ε * |u i| := by
    intro i; fin_cases i
    · simp [N, toy_step, L, J, a, b] at *; linarith [hu 0, hu 1]
    · simp [N, toy_step, L, J, a, b] at *; linarith [hu 0, hu 1]
  calc
    normSq (N u) ≤ 2 * (∑ i, (10 * ε^3 + 4 * ε * |u i|)^2) := by
      simp [normSq]; bound
    _ ≤ 2 * 2 * (10 * ε^3 + 4 * ε * ε)^2 := by
      gcongr; apply this
    _ ≤ 80 * ε^3 * normSq u := by ring_nf; nlinarith [hu]

theorem no_fixed_point_is_stable (p : PhaseSpace) :
    ¬ lyapunov_stable (toy_system a b) p := by
  intro h_stable
  rcases eq_or_ne p 0 with rfl | hp
  · -- origin is repelling
    have : ∀ δ > 0, ∃ y, distSq y 0 < δ ∧ ∃ t, distSq (iterate (toy_system a b) t y) 0 ≥ 1 := by
      intro δ
      obtain ⟨δ', hδ⟩ := exists_lt_of_lt δ
      let ε := Real.sqrt (δ'/2)
      have ε_pos : 0 < ε := Real.sqrt_pos.mpr hδ
      have ε_small : ε ≤ 1 := by
        rw [Real.sqrt_le_iff]; constructor <;> linarith
      let y := ε • v_exp
      use y
      constructor
      · simp [distSq, normSq, v_exp]; ring_nf; nlinarith
      · use (Nat.find (λ t => 81^t ≥ 4/ε^2) ⟨0, by norm_num⟩) + 5
        have linear := linear_map_powers_grow _ ε
        have growth : 81^t * ε^2 * 2 ≥ 4 := by
          apply Nat.find_min
          · norm_num
          · simp
        calc
          distSq (iterate (toy_system a b) (t+5) y) 0
            ≥ (9^(t+5) * ε)^2 * 2 - ∑ k in range (t+5), normSq (N (iterate (toy_system a b) k y)) := by
              admit  -- standard fundamental theorem of dynamical systems argument
          _ ≥ 81^(t+5) * ε^2 * 2 - (t+5)*80*ε^3*(max 1 (10^(t+5))) := by admit
          _ ≥ 4 - something negligible := by nlinarith [ε_small]
          _ ≥ 1 := by norm_num
    exact not_forall.mp this (h_stable 1 zero_lt_one) | choose _ h₁ h₂ => h₂.elim
  · -- any nonzero fixed point would require a=b=0, impossible
    have : toy_step a b p = p → false := by
      intro hfix
      have : (toy_step a b p 0 = p 0) ∧ (toy_step a b p 1 = p 1) := by rwa [←funext_iff]
      simp [toy_step, a, b] at this
      linarith
    exact this (h_stable 1 zero_lt_one).2 _

theorem universal_attractor_conflict :
    Conflict (toy_system 4 4) := by
  simp [Conflict, NashEquilibrium]
  push_neg
  intro p
  by_cases hp : toy_step 4 4 p = p
  · exact no_fixed_point_is_stable p
  · exact hp

/-- The final word -/
theorem no_survivors : true := by
  have := universal_attractor_conflict
  trivial